package com.example.dashboard.post.mapper;

import com.example.dashboard.post.Post;
import com.example.dashboard.post.dto.PostRequestDTO;
import com.example.dashboard.post.dto.PostResponseDTO;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;

import java.util.List;

/**
 * MapStruct Mapper for Post Entity and DTOs.
 *
 * MapStruct automatically generates the implementation at compile-time.
 *
 * @Mapper:
 * - componentModel = "spring" → Generates a @Component that Spring can inject
 * - Alternatives: "default" (no framework), "cdi", "jsr330"
 *
 * How does it work?
 * 1. Maven compiles the project
 * 2. MapStruct processor detects this interface
 * 3. Generates PostMapperImpl.java in target/generated-sources/
 * 4. Spring injects PostMapperImpl when PostMapper is required
 *
 * Where is the implementation?
 * - In: target/generated-sources/annotations/com/example/dashboard/post/mapper/PostMapperImpl.java
 * - You can open it in IntelliJ to see the generated code
 */
@Mapper(componentModel = "spring")
public interface PostMapper {

    /**
     * Converts PostRequestDTO → Post Entity.
     *
     * @Mapping(target = "...", ignore = true):
     * - Tells MapStruct NOT to map that field
     * - Useful for fields set elsewhere
     *
     * Ignored fields:
     * - id: Generated by the database (SERIAL/IDENTITY)
     * - author: Set by the Service using the JWT
     * - createdAt: Set by @PrePersist in the Entity
     *
     * MapStruct automatically maps:
     * - title (same name in DTO and Entity) → automatic
     * - content (same name) → automatic
     *
     * @param dto DTO from the client
     * @return Entity ready to persist (without id, author, createdAt)
     */
    @Mapping(target = "id", ignore = true)
    @Mapping(target = "author", ignore = true)
    @Mapping(target = "createdAt", ignore = true)
    Post toEntity(PostRequestDTO dto);

    /**
     * Converts Post Entity → PostResponseDTO.
     *
     * MapStruct automatically maps ALL fields because:
     * - Names match (id → id, title → title, etc.)
     * - Types are compatible
     *
     * No @Mapping is needed here because all fields map 1:1.
     *
     * @param entity Entity from the database
     * @return DTO for the client
     */
    PostResponseDTO toResponseDTO(Post entity);

    /**
     * Converts List<Post> → List<PostResponseDTO>.
     *
     * MapStruct automatically generates this method using toResponseDTO().
     * No manual implementation is needed.
     *
     * Approximate generated code:
     * <pre>
     * public List<PostResponseDTO> toResponseDTOList(List<Post> posts) {
     *     if (posts == null) return null;
     *
     *     List<PostResponseDTO> list = new ArrayList<>(posts.size());
     *     for (Post post : posts) {
     *         list.add(toResponseDTO(post));
     *     }
     *     return list;
     * }
     * </pre>
     *
     * @param posts List of entities
     * @return List of DTOs
     */
    List<PostResponseDTO> toResponseDTOList(List<Post> posts);
}
